-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shared functionality between GHC and its boot libraries
--   
--   This library is shared between GHC, ghc-pkg, and other boot libraries.
--   . A note about <a>GHC.Unit.Database</a>: it only deals with the subset
--   of the package database that the compiler cares about: modules paths
--   etc and not package metadata like description, authors etc. It is thus
--   not a library interface to ghc-pkg and is *not* suitable for modifying
--   GHC package databases. . The package database format and this library
--   are constructed in such a way that while ghc-pkg depends on Cabal, the
--   GHC library and program do not have to depend on Cabal.
@package ghc-boot
@version 9.0.2


-- | Note [Base Dir] ~~~~~~~~~~~~~~~~~
--   
--   GHC's base directory or top directory containers miscellaneous
--   settings and the package database. The main compiler of course needs
--   this directory to read those settings and read and write packages.
--   ghc-pkg uses it to find the global package database too.
--   
--   In the interest of making GHC builds more relocatable, many settings
--   also will expand `${top_dir}` inside strings so GHC doesn't need to
--   know it's on installation location at build time. ghc-pkg also can
--   expand those variables and so needs the top dir location to do that
--   too.
module GHC.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | <pre>
--   expandPathVar var value str
--   </pre>
--   
--   replaces occurrences of variable <tt>$var</tt> with <tt>value</tt> in
--   str.
expandPathVar :: String -> FilePath -> String -> String

-- | Calculate the location of the base dir
getBaseDir :: IO (Maybe String)


-- | See <tt>GHC.LanguageExtensions</tt> for an explanation on why this is
--   needed
module GHC.ForeignSrcLang
instance Data.Binary.Class.Binary GHC.ForeignSrcLang.Type.ForeignSrcLang


-- | See GHC #10762 and #15021.
module GHC.HandleEncoding

-- | Handle GHC-specific character encoding flags, allowing us to control
--   how GHC produces output regardless of OS.
configureHandleEncoding :: IO ()


-- | This module re-exports the <a>Extension</a> type along with an orphan
--   <a>Binary</a> instance for it.
--   
--   Note that the <tt>ghc-boot</tt> package has a large set of
--   dependencies; for this reason the <a>Extension</a> type itself is
--   defined in the <a>GHC.LanguageExtensions.Type</a> module provided by
--   the <tt>ghc-boot-th</tt> package, which has no dependencies outside of
--   <tt>base</tt>. For this reason <tt>template-haskell</tt> depends upon
--   <tt>ghc-boot-th</tt>, not <tt>ghc-boot</tt>.
module GHC.LanguageExtensions
instance Data.Binary.Class.Binary GHC.LanguageExtensions.Type.Extension


-- | A description of the platform we're compiling for.
module GHC.Platform

-- | Contains the bare-bones arch and os information. This isn't enough for
--   code gen, but useful for tasks where we can fall back upon the host
--   platform, as this is all we know about the host platform.
data PlatformMini
PlatformMini :: Arch -> OS -> PlatformMini
[platformMini_arch] :: PlatformMini -> Arch
[platformMini_os] :: PlatformMini -> OS
data PlatformWordSize

-- | A 32-bit platform
PW4 :: PlatformWordSize

-- | A 64-bit platform
PW8 :: PlatformWordSize

-- | Contains enough information for the native code generator to emit code
--   for this platform.
data Platform
Platform :: !PlatformMini -> !PlatformWordSize -> !ByteOrder -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> Platform
[platformMini] :: Platform -> !PlatformMini

-- | Word size
[platformWordSize] :: Platform -> !PlatformWordSize

-- | Byte order (endianness)
[platformByteOrder] :: Platform -> !ByteOrder
[platformUnregisterised] :: Platform -> !Bool
[platformHasGnuNonexecStack] :: Platform -> !Bool
[platformHasIdentDirective] :: Platform -> !Bool
[platformHasSubsectionsViaSymbols] :: Platform -> !Bool
[platformIsCrossCompiling] :: Platform -> !Bool

-- | Symbols need underscore prefix
[platformLeadingUnderscore] :: Platform -> !Bool

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in includes<i>rts</i>storage/InfoTables.h.
[platformTablesNextToCode] :: Platform -> !Bool

-- | Legacy accessor
platformArch :: Platform -> Arch

-- | Legacy accessor
platformOS :: Platform -> OS

-- | Architectures that the native code generator knows about. TODO: It
--   might be nice to extend these constructors with information about what
--   instruction set extensions an architecture might support.
data Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
[ppc_64ABI] :: Arch -> PPC_64ABI
ArchS390X :: Arch
ArchSPARC :: Arch
ArchSPARC64 :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
[armISA] :: Arch -> ArmISA
[armISAExt] :: Arch -> [ArmISAExt]
[armABI] :: Arch -> ArmABI
ArchAArch64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchJavaScript :: Arch

-- | Operating systems that the native code generator knows about. Having
--   OSUnknown should produce a sensible default, but no promises.
data OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS

-- | ARM Instruction Set Architecture, Extensions and ABI
data ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA
data ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt
data ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI

-- | PowerPC 64-bit ABI
data PPC_64ABI
ELF_V1 :: PPC_64ABI
ELF_V2 :: PPC_64ABI

-- | Byte ordering.
data ByteOrder

-- | most-significant-byte occurs in lowest address.
BigEndian :: ByteOrder

-- | least-significant-byte occurs in lowest address.
LittleEndian :: ByteOrder

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool

-- | This predicate tells us whether the OS supports ELF-like shared
--   libraries.
osElfTarget :: OS -> Bool

-- | This predicate tells us whether the OS support Mach-O shared
--   libraries.
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
platformWordSizeInBytes :: Platform -> Int
platformWordSizeInBits :: Platform -> Int

-- | Minimum representable Int value for the given platform
platformMinInt :: Platform -> Integer

-- | Maximum representable Int value for the given platform
platformMaxInt :: Platform -> Integer

-- | Maximum representable Word value for the given platform
platformMaxWord :: Platform -> Integer

-- | Test if the given Integer is representable with a platform Int
platformInIntRange :: Platform -> Integer -> Bool

-- | Test if the given Integer is representable with a platform Word
platformInWordRange :: Platform -> Integer -> Bool

-- | For some architectures the C calling convention is that any integer
--   shorter than 64 bits is replaced by its 64 bits representation using
--   sign or zero extension.
platformCConvNeedsExtension :: Platform -> Bool

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> Bool -> Bool -> String -> Bool -> Bool -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_ghcWithSMP] :: PlatformMisc -> Bool
[platformMisc_ghcRTSWays] :: PlatformMisc -> String
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_ghcThreaded] :: PlatformMisc -> Bool
[platformMisc_ghcDebugged] :: PlatformMisc -> Bool
[platformMisc_ghcRtsWithLibdw] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String

-- | See Note [Platform Syntax].
stringEncodeArch :: Arch -> String

-- | See Note [Platform Syntax].
stringEncodeOS :: OS -> String

-- | x86 SSE instructions
data SseVersion
SSE1 :: SseVersion
SSE2 :: SseVersion
SSE3 :: SseVersion
SSE4 :: SseVersion
SSE42 :: SseVersion

-- | x86 BMI (bit manipulation) instructions
data BmiVersion
BMI1 :: BmiVersion
BMI2 :: BmiVersion
instance GHC.Classes.Eq GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.OS
instance GHC.Show.Show GHC.Platform.OS
instance GHC.Read.Read GHC.Platform.OS
instance GHC.Classes.Eq GHC.Platform.ArmISA
instance GHC.Show.Show GHC.Platform.ArmISA
instance GHC.Read.Read GHC.Platform.ArmISA
instance GHC.Classes.Eq GHC.Platform.ArmISAExt
instance GHC.Show.Show GHC.Platform.ArmISAExt
instance GHC.Read.Read GHC.Platform.ArmISAExt
instance GHC.Classes.Eq GHC.Platform.ArmABI
instance GHC.Show.Show GHC.Platform.ArmABI
instance GHC.Read.Read GHC.Platform.ArmABI
instance GHC.Classes.Eq GHC.Platform.PPC_64ABI
instance GHC.Show.Show GHC.Platform.PPC_64ABI
instance GHC.Read.Read GHC.Platform.PPC_64ABI
instance GHC.Classes.Eq GHC.Platform.Arch
instance GHC.Show.Show GHC.Platform.Arch
instance GHC.Read.Read GHC.Platform.Arch
instance GHC.Classes.Eq GHC.Platform.PlatformMini
instance GHC.Show.Show GHC.Platform.PlatformMini
instance GHC.Read.Read GHC.Platform.PlatformMini
instance GHC.Classes.Eq GHC.Platform.Platform
instance GHC.Show.Show GHC.Platform.Platform
instance GHC.Read.Read GHC.Platform.Platform
instance GHC.Classes.Ord GHC.Platform.SseVersion
instance GHC.Classes.Eq GHC.Platform.SseVersion
instance GHC.Classes.Ord GHC.Platform.BmiVersion
instance GHC.Classes.Eq GHC.Platform.BmiVersion
instance GHC.Show.Show GHC.Platform.PlatformWordSize
instance GHC.Read.Read GHC.Platform.PlatformWordSize

module GHC.Platform.Host
cHostPlatformArch :: Arch
cHostPlatformOS :: OS
cHostPlatformMini :: PlatformMini

module GHC.Serialized

-- | Represents a serialized value of a particular type. Attempts can be
--   made to deserialize it at certain types
data Serialized
Serialized :: TypeRep -> [Word8] -> Serialized

-- | Put a Typeable value that we are able to actually turn into bytes into
--   a <a>Serialized</a> value ready for deserialization later
toSerialized :: forall a. Typeable a => (a -> [Word8]) -> a -> Serialized

-- | If the <a>Serialized</a> value contains something of the given type,
--   then use the specified deserializer to return <tt>Just</tt> that.
--   Otherwise return <tt>Nothing</tt>.
fromSerialized :: forall a. Typeable a => ([Word8] -> a) -> Serialized -> Maybe a

-- | Use a <a>Data</a> instance to implement a serialization scheme dual to
--   that of <a>deserializeWithData</a>
serializeWithData :: Data a => a -> [Word8]

-- | Use a <a>Data</a> instance to implement a deserialization scheme dual
--   to that of <a>serializeWithData</a>
deserializeWithData :: Data a => [Word8] -> a

module GHC.Settings.Utils
maybeRead :: Read a => String -> Maybe a
maybeReadFuzzy :: Read a => String -> Maybe a

module GHC.Settings.Platform
getTargetPlatform :: FilePath -> RawSettings -> Either String Platform
type RawSettings = Map String String

-- | See Note [Settings file] for "0" suffix
getSetting0 :: FilePath -> RawSettings -> String -> Either String String

-- | See Note [Settings file] for "0" suffix
getFilePathSetting0 :: FilePath -> FilePath -> RawSettings -> String -> Either String String

-- | See Note [Settings file] for "0" suffix
getBooleanSetting0 :: FilePath -> RawSettings -> String -> Either String Bool

-- | See Note [Settings file] for "0" suffix
readSetting0 :: (Show a, Read a) => FilePath -> RawSettings -> String -> Either String a


-- | This module provides the view of GHC's database of registered packages
--   that is shared between GHC the compiler/library, and the ghc-pkg
--   program. It defines the database format that is shared between GHC and
--   ghc-pkg.
--   
--   The database format, and this library are constructed so that GHC does
--   not have to depend on the Cabal library. The ghc-pkg program acts as
--   the gateway between the external package format (which is defined by
--   Cabal) and the internal package format which is specialised just for
--   GHC.
--   
--   GHC the compiler only needs some of the information which is kept
--   about registered packages, such as module names, various paths etc. On
--   the other hand ghc-pkg has to keep all the information from Cabal
--   packages and be able to regurgitate it for users and other tools.
--   
--   The first trick is that we duplicate some of the information in the
--   package database. We essentially keep two versions of the database in
--   one file, one version used only by ghc-pkg which keeps the full
--   information (using the serialised form of the
--   <tt>InstalledPackageInfo</tt> type defined by the Cabal library); and
--   a second version written by ghc-pkg and read by GHC which has just the
--   subset of information that GHC needs.
--   
--   The second trick is that this module only defines in detail the format
--   of the second version -- the bit GHC uses -- and the part managed by
--   ghc-pkg is kept in the file but here we treat it as an opaque blob of
--   data. That way this library avoids depending on Cabal.
module GHC.Unit.Database

-- | Information about an unit (a unit is an installed module library).
--   
--   This is a subset of Cabal's <tt>InstalledPackageInfo</tt>, with just
--   the bits that GHC is interested in.
--   
--   Some types are left as parameters to be instantiated differently in
--   ghc-pkg and in ghc itself.
data GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod
GenericUnitInfo :: uid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> String -> [uid] -> [(uid, String)] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod

-- | Unique unit identifier that is used during compilation (e.g. to
--   generate symbols).
[unitId] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> uid

-- | Identifier of an indefinite unit (i.e. with module holes) that this
--   unit is an instance of.
[unitInstanceOf] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> compid

-- | How this unit instantiates some of its module holes. Map hole module
--   names to actual module
[unitInstantiations] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(modulename, mod)]

-- | Source package identifier.
--   
--   Cabal instantiates this with Distribution.Types.PackageId.PackageId
--   type which only contains the source package name and version. Notice
--   that it doesn't contain the Hackage revision, nor any kind of hash.
[unitPackageId] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> srcpkgid

-- | Source package name
[unitPackageName] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> srcpkgname

-- | Source package version
[unitPackageVersion] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Version

-- | Name of the component.
--   
--   Cabal supports more than one components (libraries, executables,
--   testsuites) in the same package. Each component has a name except the
--   default one (that can only be a library component) for which we use
--   <a>Nothing</a>.
--   
--   GHC only deals with "library" components as they are the only kind of
--   components that can be registered in a database and used by other
--   modules.
[unitComponentName] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Maybe srcpkgname

-- | ABI hash used to avoid mixing up units compiled with different
--   dependencies, compiler, options, etc.
[unitAbiHash] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> String

-- | Identifiers of the units this one depends on
[unitDepends] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [uid]

-- | Like <a>unitDepends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[unitAbiDepends] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(uid, String)]

-- | Directories containing module interfaces
[unitImportDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Names of the Haskell libraries provided by this unit
[unitLibraries] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | Names of the external system libraries that this unit depends on. See
--   also <a>unitExtDepLibsGhc</a> field.
[unitExtDepLibsSys] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | Because of slight differences between the GHC dynamic linker (in
--   GHC.Runtime.Linker) and the native system linker, some packages have
--   to link with a different list of libraries when using GHC's. Examples
--   include: libs that are actually gnu ld scripts, and the possibility
--   that the .a libs do not exactly match the .so/.dll equivalents.
--   
--   If this field is set, then we use that instead of the
--   <a>unitExtDepLibsSys</a> field.
[unitExtDepLibsGhc] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | Directories containing libraries provided by this unit. See also
--   <a>unitLibraryDynDirs</a>.
--   
--   It seems to be used to store paths to external library dependencies
--   too.
[unitLibraryDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Directories containing the dynamic libraries provided by this unit.
--   See also <a>unitLibraryDirs</a>.
--   
--   It seems to be used to store paths to external dynamic library
--   dependencies too.
[unitLibraryDynDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Names of the external MacOS frameworks that this unit depends on.
[unitExtDepFrameworks] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | Directories containing MacOS frameworks that this unit depends on.
[unitExtDepFrameworkDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Linker (e.g. ld) command line options
[unitLinkerOptions] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | C compiler options that needs to be passed to the C compiler when we
--   compile some C code against this unit.
[unitCcOptions] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | C header files that are required by this unit (provided by this unit
--   or external)
[unitIncludes] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [String]

-- | Directories containing C header files that this unit depends on.
[unitIncludeDirs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Paths to Haddock interface files for this unit
[unitHaddockInterfaces] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Paths to Haddock directories containing HTML files
[unitHaddockHTMLs] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [FilePath]

-- | Modules exposed by the unit.
--   
--   A module can be re-exported from another package. In this case, we
--   indicate the module origin in the second parameter.
[unitExposedModules] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [(modulename, Maybe mod)]

-- | Hidden modules.
--   
--   These are useful for error reporting (e.g. if a hidden module is
--   imported)
[unitHiddenModules] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> [modulename]

-- | True if this unit has some module holes that need to be instantiated
--   with real modules to make the unit usable (a.k.a. Backpack).
[unitIsIndefinite] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is exposed. A unit could be installed in a database
--   by "disabled" by not being exposed.
[unitIsExposed] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | True if the unit is trusted (cf Safe Haskell)
[unitIsTrusted] :: GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod -> Bool

-- | <tt>ghc-boot</tt>'s UnitInfo, serialized to the database.
type DbUnitInfo = GenericUnitInfo ByteString ByteString ByteString ByteString ByteString DbModule

-- | <tt>ghc-boot</tt>'s <tt>Module</tt>, serialized to the database.
data DbModule
DbModule :: DbInstUnitId -> ByteString -> DbModule
[dbModuleUnitId] :: DbModule -> DbInstUnitId
[dbModuleName] :: DbModule -> ByteString
DbModuleVar :: ByteString -> DbModule
[dbModuleVarName] :: DbModule -> ByteString

-- | <tt>ghc-boot</tt>'s instantiated unit id, serialized to the database.
data DbInstUnitId

-- | Instantiated unit
DbInstUnitId :: ByteString -> [(ByteString, DbModule)] -> DbInstUnitId

-- | Uninstantiated unit
DbUnitId :: ByteString -> DbInstUnitId

-- | Convert between GenericUnitInfo instances
mapGenericUnitInfo :: (uid1 -> uid2) -> (cid1 -> cid2) -> (srcpkg1 -> srcpkg2) -> (srcpkgname1 -> srcpkgname2) -> (modname1 -> modname2) -> (mod1 -> mod2) -> GenericUnitInfo cid1 srcpkg1 srcpkgname1 uid1 modname1 mod1 -> GenericUnitInfo cid2 srcpkg2 srcpkgname2 uid2 modname2 mod2

-- | Mode to open a package db in.
data DbMode
DbReadOnly :: DbMode
DbReadWrite :: DbMode

-- | <a>DbOpenMode</a> holds a value of type <tt>t</tt> but only in
--   <a>DbReadWrite</a> mode. So it is like <a>Maybe</a> but with a type
--   argument for the mode to enforce that the mode is used consistently.
data DbOpenMode (mode :: DbMode) t
[DbOpenReadOnly] :: DbOpenMode 'DbReadOnly t
[DbOpenReadWrite] :: t -> DbOpenMode 'DbReadWrite t
isDbOpenReadMode :: DbOpenMode mode t -> Bool

-- | Read the part of the package DB that GHC is interested in.
readPackageDbForGhc :: FilePath -> IO [DbUnitInfo]

-- | Read the part of the package DB that ghc-pkg is interested in
--   
--   Note that the Binary instance for ghc-pkg's representation of packages
--   is not defined in this package. This is because ghc-pkg uses Cabal
--   types (and Binary instances for these) which this package does not
--   depend on.
--   
--   If we open the package db in read only mode, we get its contents.
--   Otherwise we additionally receive a PackageDbLock that represents a
--   lock on the database, so that we can safely update it later.
readPackageDbForGhcPkg :: Binary pkgs => FilePath -> DbOpenMode mode t -> IO (pkgs, DbOpenMode mode PackageDbLock)

-- | Write the whole of the package DB, both parts.
writePackageDb :: Binary pkgs => FilePath -> [DbUnitInfo] -> pkgs -> IO ()

-- | Represents a lock of a package db.
data PackageDbLock

-- | Acquire an exclusive lock related to package DB under given location.
lockPackageDb :: FilePath -> IO PackageDbLock

-- | Release the lock related to package DB.
unlockPackageDb :: PackageDbLock -> IO ()
mkMungePathUrl :: FilePath -> FilePath -> (FilePath -> FilePath, FilePath -> FilePath)

-- | Perform path/URL variable substitution as per the Cabal ${pkgroot}
--   spec
--   (http:/<i>www.haskell.org</i>pipermail<i>libraries</i>2009-May/011772.html)
--   Paths/URLs can be relative to ${pkgroot} or ${pkgrooturl}. The
--   "pkgroot" is the directory containing the package database.
--   
--   Also perform a similar substitution for the older GHC-specific
--   "$topdir" variable. The "topdir" is the location of the ghc
--   installation (obtained from the -B option).
mungeUnitInfoPaths :: FilePath -> FilePath -> GenericUnitInfo a b c d e f -> GenericUnitInfo a b c d e f
instance (GHC.Show.Show uid, GHC.Show.Show compid, GHC.Show.Show modulename, GHC.Show.Show mod, GHC.Show.Show srcpkgid, GHC.Show.Show srcpkgname) => GHC.Show.Show (GHC.Unit.Database.GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod)
instance (GHC.Classes.Eq uid, GHC.Classes.Eq compid, GHC.Classes.Eq modulename, GHC.Classes.Eq mod, GHC.Classes.Eq srcpkgid, GHC.Classes.Eq srcpkgname) => GHC.Classes.Eq (GHC.Unit.Database.GenericUnitInfo compid srcpkgid srcpkgname uid modulename mod)
instance GHC.Show.Show GHC.Unit.Database.DbModule
instance GHC.Classes.Eq GHC.Unit.Database.DbModule
instance GHC.Show.Show GHC.Unit.Database.DbInstUnitId
instance GHC.Classes.Eq GHC.Unit.Database.DbInstUnitId
instance GHC.Base.Functor (GHC.Unit.Database.DbOpenMode mode)
instance Data.Foldable.Foldable (GHC.Unit.Database.DbOpenMode mode)
instance Data.Traversable.Traversable (GHC.Unit.Database.DbOpenMode mode)
instance Data.Binary.Class.Binary GHC.Unit.Database.DbUnitInfo
instance Data.Binary.Class.Binary GHC.Unit.Database.DbModule
instance Data.Binary.Class.Binary GHC.Unit.Database.DbInstUnitId

module GHC.Version
cProjectGitCommitId :: String
cProjectVersion :: String
cProjectVersionInt :: String
cProjectPatchLevel :: String
cProjectPatchLevel1 :: String
cProjectPatchLevel2 :: String

module GHC.UniqueSubdir

-- | A filepath like <tt>x86_64-linux-7.6.3</tt> with the platform string
--   to use when constructing platform-version-dependent files that need to
--   co-exist.
--   
--   'ghc-pkg' falls back on the host platform if the settings file is
--   missing, and so needs this since we don't have information about the
--   host platform in as much detail as <a>Platform</a>, so we use
--   <a>PlatformMini</a> instead.
uniqueSubdir :: PlatformMini -> FilePath
